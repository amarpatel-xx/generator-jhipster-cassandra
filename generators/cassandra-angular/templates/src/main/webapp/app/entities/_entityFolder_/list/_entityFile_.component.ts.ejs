<%#
 Copyright 2013-2024 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
<%_
  const notSortableFieldsAfterSearchArray = searchEngineNo ? [] : fields
      .filter(field => !field.hidden && !field.fieldTypeBoolean && !field.fieldTypeNumeric && !field.fieldTypeTemporal);

  const notSortableFieldsAfterSearchFieldNames = notSortableFieldsAfterSearchArray
      .map(field => field.fieldName);

  const notSortableFieldsAfterSearch = notSortableFieldsAfterSearchArray
      .map(field => `'${field.fieldName}'`)
      .join(', ');

  const componentName = entityAngularName + 'Component';

  // Saathratri: Get composite key field names for sorting
  const compositeKeyFieldNames = primaryKeySaathratri.composite
    ? fields.filter(f => f.isCompositePrimaryKeyField).map(f => `'${f.fieldName}'`).join(', ')
    : '';
_%>
import { Component, computed, NgZone, inject, OnInit, signal, WritableSignal<%_ if (paginationInfiniteScroll || (databaseTypeCassandra && paginationNo)) { _%>, HostListener<%_ } _%><%_ if (paginationInfiniteScroll) { _%>, ViewChild, ElementRef<%_ } _%> } from '@angular/core';
<%_ if (!paginationNo || (databaseTypeCassandra && paginationNo)) { _%>
import { HttpHeaders<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>, HttpResponse<%_ } _%> } from '@angular/common/http';
<%_ } _%>
import { ActivatedRoute, Data, ParamMap, Router, RouterModule } from '@angular/router';
import { combineLatest<%_ if (!readOnly) { _%>, filter<%_ } _%><%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>, map<%_ } _%>, Observable, Subscription, tap } from 'rxjs';
<%_ if (!readOnly) { _%>
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
<%_ } _%>

import SharedModule from 'app/shared/shared.module';
import { sortStateSignal, SortDirective, SortByDirective, type SortState, SortService } from 'app/shared/sort';
import { DurationPipe, FormatMediumDatetimePipe, FormatMediumDatePipe, FormatUtcDatePipe, ConvertFromDayjsToDateLongPipe } from 'app/shared/date';
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>
import dayjs from 'dayjs/esm';
import customParseFormat from 'dayjs/esm/plugin/customParseFormat';
dayjs.extend(customParseFormat);
import { MaterialModule } from 'app/shared/material.module';
<%_ } _%>
<%_ if (paginationPagination) { _%>
import { ItemCountComponent } from 'app/shared/pagination';
<%_ } _%>
<%_ if (searchEngine || (databaseTypeCassandra && primaryKeySaathratri.composite)) { _%>
import { FormsModule } from '@angular/forms';
<%_ } _%>
<%_ if (primaryKeySaathratri.composite) { _%>
    // Saathratri: Composite Primary Key Code
    import { I<%= entityAngularName %>, I<%= entityAngularName %>Id } from '../<%= entityFileName %>.model';
<%_ } else { _%>
    // Saathratri: Single-value Primary Key Code
import { I<%= entityAngularName %> } from '../<%= entityFileName %>.model';
<%_ } // Saathratri _%>
<%_ if (!paginationNo) { %>
import {
  ITEMS_PER_PAGE,
<%_ if (paginationPagination) { _%>
  PAGE_HEADER,
<%_ } _%>
<%_ if (paginationPagination) { _%>
  TOTAL_COUNT_RESPONSE_HEADER,
<%_ } _%>
} from 'app/config/pagination.constants';
<%_ } _%>
import {
  SORT,
<%_ if (!readOnly) { _%>
  ITEM_DELETED_EVENT,
<%_ } _%>
  DEFAULT_SORT_DATA
} from 'app/config/navigation.constants';
import { EntityArrayResponseType<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>, EntityResponseType<%_ } _%>, <%= entityAngularName %>Service } from '../service/<%= entityFileName %>.service';
<%_ if (!readOnly) { _%>
import { <%= entityAngularName %>DeleteDialogComponent } from '../delete/<%= entityFileName %>-delete-dialog.component';
<%_ } _%>
<%_ if (anyFieldIsBlobDerived) { _%>
import { DataUtils } from 'app/core/util/data-util.service';
<%_ } _%>
<%_ if (paginationInfiniteScroll) { _%>
import { ParseLinks } from 'app/core/util/parse-links.service';
<%_ } _%>
<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
import { FilterComponent, FilterOptions, IFilterOptions, IFilterOption } from 'app/shared/filter';
<%_ } _%>
<%_ if (paginationInfiniteScroll) { _%>
import { InfiniteScrollDirective } from 'ngx-infinite-scroll';
<%_ } _%>

@Component({
    standalone: true,
    selector: '<%= jhiPrefixDashed %>-<%= entityFileName %>',
    templateUrl: './<%= entityFileName %>.component.html',
    imports: [
      RouterModule,
<%_ if (searchEngine || (databaseTypeCassandra && primaryKeySaathratri.composite)) { _%>
      FormsModule,
<%_ } _%>
      SharedModule,
      SortDirective,
      SortByDirective,
      DurationPipe,
      FormatMediumDatetimePipe,
      FormatMediumDatePipe,
      FormatUtcDatePipe,
      ConvertFromDayjsToDateLongPipe,
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>
      MaterialModule,
<%_ } _%>
<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
      FilterComponent,
<%_ } _%>
<%_ if (paginationPagination) { _%>
      ItemCountComponent,
<%_ } _%>
<%_ if (paginationInfiniteScroll) { _%>
      InfiniteScrollDirective,
<%_ } _%>
    ],
})
export class <%= componentName %> implements OnInit {

<%_ if (notSortableFieldsAfterSearch) { _%>
    private static readonly NOT_SORTABLE_FIELDS_AFTER_SEARCH = [<%- notSortableFieldsAfterSearch %>];

<%_ } _%>
    subscription: Subscription | null = null;
    <%= entityInstancePlural %>?: I<%= entityAngularName %>[];
    isLoading = false;
<%_ if (paginationInfiniteScroll) { _%>
    isLoadingMore = false;
<%_ } _%>
<%_ if (databaseTypeCassandra && paginationNo) { _%>
    isLoadingMore = false;

    // Cassandra Slice pagination state (cursor-based)
    pagingState: string | null = null;
    pageSize = 20;
    hasNextPage = false;
    totalItems: number | null = null;
<%_ } _%>
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) {
    const partitionKeyFields = fields.filter(f => f.isPartitionedKeySaathratri);
    const clusteringKeyFields = fields.filter(f => f.isClusteredKeySaathratri);
    // Note: Comparison operators supported: 'eq' | 'lt' | 'lte' | 'gt' | 'gte'
_%>

    // Cassandra search form state
    isSearchFormCollapsed = true;
    isSearchActive = false;
    searchCriteria: {
<%_ for (const field of partitionKeyFields) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        // DateTime picker fields for <%= field.fieldName %>
        <%= field.fieldName %>Date: Date | null;
        <%= field.fieldName %>Hour: number | null;
        <%= field.fieldName %>Minute: number | null;
        <%= field.fieldName %>AmPm: string | null;
        <%= field.fieldName %>: number | null; // Computed timestamp
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        // Date picker field for <%= field.fieldName %>
        <%= field.fieldName %>Date: Date | null;
        <%= field.fieldName %>: number | null; // Computed timestamp
  <%_ } else if (field.fieldType === 'Boolean') { _%>
        <%= field.fieldName %>: boolean | null;
  <%_ } else if (field.fieldTypeNumeric) { _%>
        <%= field.fieldName %>: number | null;
  <%_ } else { _%>
        <%= field.fieldName %>: string | null;
  <%_ } _%>
<%_ } _%>
<%_ for (const field of clusteringKeyFields) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        // DateTime picker fields for <%= field.fieldName %> with comparison operator
        <%= field.fieldName %>Operator: string | null;
        <%= field.fieldName %>Date: Date | null;
        <%= field.fieldName %>Hour: number | null;
        <%= field.fieldName %>Minute: number | null;
        <%= field.fieldName %>AmPm: string | null;
        <%= field.fieldName %>: number | null; // Computed timestamp
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        // Date picker field for <%= field.fieldName %> with comparison operator
        <%= field.fieldName %>Operator: string | null;
        <%= field.fieldName %>Date: Date | null;
        <%= field.fieldName %>: number | null; // Computed timestamp
  <%_ } else if (field.fieldType === 'Boolean') { _%>
        <%= field.fieldName %>: boolean | null;
  <%_ } else if (field.fieldTypeNumeric || field.fieldType === 'Long') { _%>
        // Numeric field with comparison operator
        <%= field.fieldName %>Operator: string | null;
        <%= field.fieldName %>: number | null;
  <%_ } else if (field.fieldTypeTimeUuidSaathratri) { _%>
        // TimeUUID field with comparison operator (string type)
        <%= field.fieldName %>Operator: string | null;
        <%= field.fieldName %>: string | null;
  <%_ } else { _%>
        <%= field.fieldName %>: string | null;
  <%_ } _%>
<%_ } _%>
    } = {
<%_ for (const field of partitionKeyFields) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        <%= field.fieldName %>Date: null,
        <%= field.fieldName %>Hour: null,
        <%= field.fieldName %>Minute: null,
        <%= field.fieldName %>AmPm: null,
        <%= field.fieldName %>: null,
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        <%= field.fieldName %>Date: null,
        <%= field.fieldName %>: null,
  <%_ } else { _%>
        <%= field.fieldName %>: null,
  <%_ } _%>
<%_ } _%>
<%_ for (const field of clusteringKeyFields) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        <%= field.fieldName %>Operator: 'eq',
        <%= field.fieldName %>Date: null,
        <%= field.fieldName %>Hour: null,
        <%= field.fieldName %>Minute: null,
        <%= field.fieldName %>AmPm: null,
        <%= field.fieldName %>: null,
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        <%= field.fieldName %>Operator: 'eq',
        <%= field.fieldName %>Date: null,
        <%= field.fieldName %>: null,
  <%_ } else if (field.fieldTypeNumeric || field.fieldType === 'Long') { _%>
        <%= field.fieldName %>Operator: 'eq',
        <%= field.fieldName %>: null,
  <%_ } else if (field.fieldTypeTimeUuidSaathratri) { _%>
        <%= field.fieldName %>Operator: 'eq',
        <%= field.fieldName %>: null,
  <%_ } else { _%>
        <%= field.fieldName %>: null,
  <%_ } _%>
<%_ } _%>
    };
<%_ } _%>

    sortState = sortStateSignal({});
<%_ if (searchEngineAny) { _%>
    currentSearch = '';
<%_ } _%>
<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
    filters: IFilterOptions = new FilterOptions();
<%_ } _%>

<%_ if (paginationPagination) { _%>
<%- include('pagination-template'); -%>
<%_ } else if (paginationInfiniteScroll) { _%>
    itemsPerPage = ITEMS_PER_PAGE;
    links: WritableSignal<Record<string, undefined | Record<string, string | undefined>>> = signal({});
    hasMorePage = computed(() => !!this.links().next);
    get hasMorePages(): boolean {
      return this.hasMorePage();
    }
    isFirstFetch = computed(() => Object.keys(this.links()).length === 0);
    @ViewChild('scrollContainer', { read: ElementRef }) scrollContainer?: ElementRef;
<%_ } _%>

    public readonly router = inject(Router);
    protected readonly <%= entityInstance %>Service = inject(<%= entityAngularName %>Service);
    protected readonly activatedRoute = inject(ActivatedRoute);
    protected readonly sortService = inject(SortService);
<%_ if (paginationInfiniteScroll) { _%>
    protected parseLinks = inject(ParseLinks);
<%_ } _%>
<%_ if (anyFieldIsBlobDerived) { _%>
    protected dataUtils = inject(DataUtils);
<%_ } _%>
<%_ if (!readOnly) { _%>
    protected modalService = inject(NgbModal);
<%_ } _%>
    protected ngZone = inject(NgZone);
<%_ if (primaryKeySaathratri.composite) { _%>
      // Saathratri: Composite Primary Key Code
    track<%= primaryKeySaathratri.nameCapitalized %> = (_index: number, item: I<%= entityAngularName %>): string => this.getCompositeKey(item);
<%_ } else { _%>
      // Saathratri: Single-value Primary Key Code
    track<%= primaryKey.nameCapitalized %> = (item: I<%= entityAngularName %>): <%= primaryKey.tsType %> => this.<%= entityInstance %>Service.get<%= entityAngularName %>Identifier(item);
<%_ } _%>

    ngOnInit(): void {
      this.subscription = combineLatest([this.activatedRoute.queryParamMap, this.activatedRoute.data]).pipe(
        tap(([params, data]) => this.fillComponentAttributeFromRoute(params, data)),
<%_ if (paginationInfiniteScroll) { _%>
        tap(() => this.reset()),
<%_ } _%>
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>
        // For Cassandra entities with composite keys, load data by default
        // When search is active, filtered results will be shown
        tap(() => {
          if (!this.<%= entityInstancePlural %> || this.<%= entityInstancePlural %>.length === 0) {
            this.load();
          }
        }),
<%_ } else if (!paginationNo || searchEngineAny || jpaMetamodelFiltering) { _%>
        tap(() => this.load()),
<%_ } else { _%>
        tap(() => {
          if (!this.<%= entityInstancePlural %> || this.<%= entityInstancePlural %>.length === 0) {
            this.load();
          }
        }),
<%_ } _%>
      ).subscribe();

<% if (jpaMetamodelFiltering && paginationPagination) { %>
      this.filters.filterChanges.subscribe(filterOptions => this.handleNavigation(1, this.sortState(), filterOptions));
<%_ } _%>
    }

<%_ if (paginationInfiniteScroll) { _%>
    reset(): void {
      this.<%= entityInstancePlural %> = [];
    }

    loadNextPage(): void {
      this.load();
    }

    /**
     * Detect scroll position and load more when near bottom (alternative to infinite-scroll directive)
     * Use this for Material Design tables or when you need more control over scroll behavior
     */
    @HostListener('scroll', ['$event'])
    onScroll(event: any): void {
      const container = event.target;
      const scrollTop = container.scrollTop;
      const scrollHeight = container.scrollHeight;
      const offsetHeight = container.offsetHeight;
      const scrollThreshold = 200; // Load more when 200px from bottom

      const isNearBottom = scrollTop + offsetHeight >= scrollHeight - scrollThreshold;

      if (isNearBottom && !this.isLoading && !this.isLoadingMore && this.hasMorePage()) {
        this.isLoadingMore = true;
        this.loadNextPage();
      }
    }

<%_ } _%>
<%_ if (searchEngineAny) { _%>
    search(query: string): void {
  <%_ if (notSortableFieldsAfterSearch) { _%>
      const { predicate } = this.sortState();
      if (query && predicate && <%= componentName %>.NOT_SORTABLE_FIELDS_AFTER_SEARCH.includes(predicate)) {
        this.loadDefaultSortState();
      }
  <%_ } _%>
  <%_ if (paginationPagination) { _%>
      this.page = 1;
  <%_ } _%>
      this.currentSearch = query;
      this.navigateToWithComponentValues(this.sortState());
    }

    loadDefaultSortState(): void {
  <%_ if (notSortableFieldsAfterSearchFieldNames.includes(primaryKey.name)) { _%>
      this.sortState.set({});
  <%_ } else { _%>
      this.sortState.set(this.sortService.parseSortParam(this.activatedRoute.snapshot.data[DEFAULT_SORT_DATA]));
  <%_ } _%>
    }
<%_ } _%>

<%_ if (anyFieldIsBlobDerived) { _%>
    byteSize(base64String: string): string {
      return this.dataUtils.byteSize(base64String);
    }

    openFile(base64String: string, contentType: string | null | undefined): void {
      return this.dataUtils.openFile(base64String, contentType);
    }

<%_ } _%>
<%_ if (!readOnly) { _%>
    delete(<%= entityInstance %>: I<%= entityAngularName %>): void {
      const modalRef = this.modalService.open(<%= entityAngularName %>DeleteDialogComponent, { size: 'lg', backdrop: 'static' });
      modalRef.componentInstance.<%= entityInstance %> = <%= entityInstance %>;
      // unsubscribe not needed because closed completes on modal close
      modalRef.closed
        .pipe(
          filter(reason => reason === ITEM_DELETED_EVENT),
<%_ if (databaseTypeCassandra && paginationNo) { _%>
          tap(() => this.reset())
<%_ } else { _%>
          tap(() => this.load())
<%_ } _%>
        ).subscribe();
    }

<%_ } _%>
    load(): void {
      this.queryBackend().subscribe({
        next: (res: EntityArrayResponseType) => {
          this.onResponseSuccess(res);
<%_ if (paginationInfiniteScroll) { _%>
          this.isLoadingMore = false;
<%_ } _%>
        }
      });
    }

<%_ if (databaseTypeCassandra && paginationNo) { _%>
    reset(): void {
      this.pagingState = null;
      this.hasNextPage = false;
      this.totalItems = null;
      this.<%= entityInstancePlural %> = [];
      this.load();
    }

    loadMore(): void {
      if (this.hasNextPage && !this.isLoadingMore) {
        this.isLoadingMore = true;
        this.queryBackend().subscribe({
          next: (res: EntityArrayResponseType) => {
            this.onResponseSuccess(res, true);
            this.isLoadingMore = false;
          },
          error: () => {
            this.isLoadingMore = false;
          },
        });
      }
    }

    @HostListener('window:scroll', ['$event'])
    onScroll(): void {
      // Check if user has scrolled near the bottom of the page
      const scrollPosition = window.scrollY + window.innerHeight;
      const pageHeight = document.documentElement.scrollHeight;
      const threshold = 200; // Trigger 200px before bottom

      if (scrollPosition >= pageHeight - threshold && this.hasNextPage && !this.isLoadingMore && !this.isLoading) {
        this.loadMore();
      }
    }

<%_ } _%>
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) {
    const partitionKeyFieldsForMethods = fields.filter(f => f.isPartitionedKeySaathratri);
_%>
    // Cassandra search form methods
    toggleSearchForm(): void {
        this.isSearchFormCollapsed = !this.isSearchFormCollapsed;
    }

    hasActiveSearch(): boolean {
        return this.isSearchActive;
    }

    isSearchFormValid(): boolean {
        // All partition key fields must have values
<%_ for (const field of partitionKeyFieldsForMethods) { _%>
  <%_ if (field.fieldTypeTimedSaathratri || field.fieldTypeLocalDateSaathratri) { _%>
        // For date/datetime fields, check the computed timestamp (set by onSearchDateChange)
        if (this.searchCriteria.<%= field.fieldName %> === null || this.searchCriteria.<%= field.fieldName %> === undefined) {
            return false;
        }
  <%_ } else if (field.fieldType === 'String') { _%>
        if (this.searchCriteria.<%= field.fieldName %> === null || this.searchCriteria.<%= field.fieldName %> === undefined || this.searchCriteria.<%= field.fieldName %> === '') {
            return false;
        }
  <%_ } else { _%>
        if (this.searchCriteria.<%= field.fieldName %> === null || this.searchCriteria.<%= field.fieldName %> === undefined) {
            return false;
        }
  <%_ } _%>
<%_ } _%>
        return true;
    }

<%_
    // Get ALL clustering fields in order
    const allClusteringFields = fields.filter(f => f.isClusteredKeySaathratri);
    // Get clustering fields that have operators (date/datetime/Long/TimeUUID types)
    const clusteringFieldsWithOperators = allClusteringFields.filter(f =>
        f.fieldTypeTimedSaathratri || f.fieldTypeLocalDateSaathratri ||
        f.fieldTypeNumeric || f.fieldType === 'Long' || f.fieldTypeTimeUuidSaathratri
    );
_%>
    /**
     * Check if a clustering key field should be disabled based on Cassandra query rules.
     * In Cassandra, once an inequality operator is used on a clustering column,
     * subsequent clustering columns cannot be filtered.
     */
    isClusteringFieldDisabled(fieldName: string): boolean {
        const criteria = this.searchCriteria as any;
        // Ordered list of ALL clustering fields
        const allClusteringFields: string[] = [<%- allClusteringFields.map(f => `'${f.fieldName}'`).join(', ') %>];
        // Fields that have operators
        const fieldsWithOperators: string[] = [<%- clusteringFieldsWithOperators.map(f => `'${f.fieldName}'`).join(', ') %>];

        const fieldIndex = allClusteringFields.indexOf(fieldName);
        if (fieldIndex <= 0) {
            // First field - never disabled
            return false;
        }

        // Check all PRECEDING clustering fields that have operators
        for (let i = 0; i < fieldIndex; i++) {
            const prevFieldName = allClusteringFields[i];
            // Only check fields that have operators
            if (fieldsWithOperators.includes(prevFieldName)) {
                const prevOperator = criteria[prevFieldName + 'Operator'];

                // If a preceding field has an inequality operator, disable this field
                // (Cassandra doesn't allow filtering subsequent columns after an inequality)
                if (prevOperator && prevOperator !== 'eq') {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Called when an operator changes - clears values of subsequent disabled fields
     */
    onOperatorChange(fieldName: string): void {
        const criteria = this.searchCriteria as any;
        // Ordered list of ALL clustering fields
        const allClusteringFields: string[] = [<%- allClusteringFields.map(f => `'${f.fieldName}'`).join(', ') %>];
        // Fields that have operators
        const fieldsWithOperators: string[] = [<%- clusteringFieldsWithOperators.map(f => `'${f.fieldName}'`).join(', ') %>];

        const fieldIndex = allClusteringFields.indexOf(fieldName);
        if (fieldIndex < 0) return;

        // Clear values of all subsequent fields if this field has inequality
        const operator = criteria[fieldName + 'Operator'];
        if (operator && operator !== 'eq') {
            for (let i = fieldIndex + 1; i < allClusteringFields.length; i++) {
                const nextFieldName = allClusteringFields[i];
                criteria[nextFieldName] = null;
                // Also reset operator if this field has one
                if (fieldsWithOperators.includes(nextFieldName)) {
                    criteria[nextFieldName + 'Operator'] = 'eq';
                }
                // Also clear date picker related fields if they exist
                if (criteria[nextFieldName + 'Date'] !== undefined) {
                    criteria[nextFieldName + 'Date'] = null;
                }
                if (criteria[nextFieldName + 'Hour'] !== undefined) {
                    criteria[nextFieldName + 'Hour'] = null;
                    criteria[nextFieldName + 'Minute'] = null;
                    criteria[nextFieldName + 'AmPm'] = null;
                }
            }
        }
    }

    performSearch(): void {
        if (!this.isSearchFormValid()) {
            return;
        }
        this.isSearchActive = true;
        this.pagingState = null;
        this.hasNextPage = false;
        this.totalItems = null;
        this.<%= entityInstancePlural %> = [];
        this.load();
    }

    clearSearch(): void {
        // Reset all search criteria including date picker fields
<%_ for (const field of partitionKeyFieldsForMethods) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        // Reset datetime picker fields for <%= field.fieldName %>
        this.searchCriteria.<%= field.fieldName %>Date = null;
        this.searchCriteria.<%= field.fieldName %>Hour = null;
        this.searchCriteria.<%= field.fieldName %>Minute = null;
        this.searchCriteria.<%= field.fieldName %>AmPm = null;
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        // Reset date picker fields for <%= field.fieldName %>
        this.searchCriteria.<%= field.fieldName %>Date = null;
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else { _%>
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } _%>
<%_ } _%>
<%_ const clusteringKeyFieldsForMethods = fields.filter(f => f.isClusteredKeySaathratri); _%>
<%_ for (const field of clusteringKeyFieldsForMethods) { _%>
  <%_ if (field.fieldTypeTimedSaathratri) { _%>
        // Reset datetime picker fields for <%= field.fieldName %> with operator
        this.searchCriteria.<%= field.fieldName %>Operator = 'eq';
        this.searchCriteria.<%= field.fieldName %>Date = null;
        this.searchCriteria.<%= field.fieldName %>Hour = null;
        this.searchCriteria.<%= field.fieldName %>Minute = null;
        this.searchCriteria.<%= field.fieldName %>AmPm = null;
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else if (field.fieldTypeLocalDateSaathratri) { _%>
        // Reset date picker fields for <%= field.fieldName %> with operator
        this.searchCriteria.<%= field.fieldName %>Operator = 'eq';
        this.searchCriteria.<%= field.fieldName %>Date = null;
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else if (field.fieldTypeNumeric || field.fieldType === 'Long') { _%>
        // Reset numeric field with operator
        this.searchCriteria.<%= field.fieldName %>Operator = 'eq';
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else if (field.fieldTypeTimeUuidSaathratri) { _%>
        // Reset TimeUUID field with operator
        this.searchCriteria.<%= field.fieldName %>Operator = 'eq';
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } else { _%>
        this.searchCriteria.<%= field.fieldName %> = null;
  <%_ } _%>
<%_ } _%>
        this.isSearchActive = false;
        this.pagingState = null;
        this.hasNextPage = false;
        this.totalItems = null;
        this.<%= entityInstancePlural %> = [];
        // Reload default data (all records)
        this.load();
    }

    /**
     * Convert date picker values to timestamp for a specific field.
     * This method is called when date/time picker values change.
     * @param fieldName The name of the field being updated
     * @param isDateTime Whether this is a datetime field (true) or date-only field (false)
     */
    onSearchDateChange(fieldName: string, isDateTime: boolean = false): void {
        const criteria = this.searchCriteria as any;
        const dateValue: Date | null = criteria[fieldName + 'Date'];

        if (!dateValue) {
            criteria[fieldName] = null;
            return;
        }

        if (isDateTime) {
            // For datetime fields, combine date with hour/minute/ampm
            const hour: number | null = criteria[fieldName + 'Hour'];
            const minute: number | null = criteria[fieldName + 'Minute'];
            const amPm: string | null = criteria[fieldName + 'AmPm'];

            if (hour === null || minute === null || !amPm) {
                // If time components are not set, just use the date at midnight
                const combinedDateTime = new Date(dateValue);
                combinedDateTime.setHours(0, 0, 0, 0);
                criteria[fieldName] = combinedDateTime.getTime();
                return;
            }

            // Convert 12-hour to 24-hour format
            let adjustedHours = hour;
            if (amPm === 'PM' && hour !== 12) {
                adjustedHours = hour + 12;
            } else if (amPm === 'AM' && hour === 12) {
                adjustedHours = 0;
            }

            const combinedDateTime = new Date(dateValue);
            combinedDateTime.setHours(adjustedHours, minute, 0, 0);
            criteria[fieldName] = combinedDateTime.getTime();
        } else {
            // For date-only fields, use the date at UTC midnight
            // The database stores dates as UTC timestamps, so we must convert
            // the local date picker value to UTC midnight for accurate comparison
            const dateOnly = new Date(dateValue);
            // Create UTC midnight timestamp (not local midnight)
            const utcMidnight = Date.UTC(
                dateOnly.getFullYear(),
                dateOnly.getMonth(),
                dateOnly.getDate(),
                0, 0, 0, 0
            );
            criteria[fieldName] = utcMidnight;
        }
    }

    /**
     * Parse a human-readable date string to timestamp (milliseconds).
     * Supports formats: "9 Dec 2025" (date only) or "9 Dec 2025, 14:30:00" (datetime)
     */
    protected parseDateToTimestamp(dateStr: string | null): number | null {
        if (!dateStr || dateStr.trim() === '') {
            return null;
        }

        // Try datetime format first: "9 Dec 2025, 14:30:00"
        let parsed = dayjs(dateStr, 'D MMM YYYY, HH:mm:ss', true);
        if (parsed.isValid()) {
            return parsed.valueOf();
        }

        // Try datetime format without seconds: "9 Dec 2025, 14:30"
        parsed = dayjs(dateStr, 'D MMM YYYY, HH:mm', true);
        if (parsed.isValid()) {
            return parsed.valueOf();
        }

        // Try date-only format: "9 Dec 2025"
        parsed = dayjs(dateStr, 'D MMM YYYY', true);
        if (parsed.isValid()) {
            return parsed.valueOf();
        }

        // Fallback: try standard parsing
        parsed = dayjs(dateStr);
        if (parsed.isValid()) {
            return parsed.valueOf();
        }

        return null;
    }

<%_ } _%>
    navigateToWithComponentValues(event: SortState): void {
      this.handleNavigation(<% if (paginationPagination) { %>this.page, <% } %>event<% if (jpaMetamodelFiltering && paginationPagination) { %>, this.filters.filterOptions<% } %><% if (searchEngineAny) { %>, this.currentSearch<% } %>);
    }

<%_ if (paginationPagination) { _%>
    navigateToPage(page: number): void {
      this.handleNavigation(page, this.sortState()<% if (jpaMetamodelFiltering && paginationPagination) { %>, this.filters.filterOptions<% } %><% if (searchEngineAny) { %>, this.currentSearch<% } %>);
    }

<%_ } _%>

<%_ if (anyFieldIsSetSaathratri) { _%>
  toArray(set: Set<string> | null | undefined): string[] {
    return set ? Array.from(set) : [];
  }
<%_ } _%>

    protected fillComponentAttributeFromRoute(params: ParamMap, data: Data): void {
<%_ if (paginationPagination) { _%>
      const page = params.get(PAGE_HEADER);
      this.page = +(page ?? 1);
<%_ } _%>
      this.sortState.set(this.sortService.parseSortParam(params.get(SORT) ?? data[DEFAULT_SORT_DATA]));
<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
      this.filters.initializeFromParams(params);
<%_ } _%>
<%_ if (searchEngineAny) { _%>
      if (params.has('search') && params.get('search') !== '') {
        this.currentSearch = params.get('search') as string;
  <%_ if (notSortableFieldsAfterSearch) { _%>
          const { predicate } = this.sortState();
          if (predicate && <%= componentName %>.NOT_SORTABLE_FIELDS_AFTER_SEARCH.includes(predicate)) {
            this.sortState.set({});
          }
  <%_ } _%>
      }
<%_ } _%>
    }

    protected onResponseSuccess(response: EntityArrayResponseType, append = false): void {
<%_ if (!paginationNo) { _%>
      this.fillComponentAttributesFromResponseHeader(response.headers);
<%_ } _%>
<%_ if (databaseTypeCassandra && paginationNo) { _%>
      this.extractPaginationHeaders(response.headers);
<%_ } _%>
      const dataFromBody = this.fillComponentAttributesFromResponseBody(response.body);
<%_ if (paginationNo) { _%>
<%_ if (databaseTypeCassandra) { _%>

      if (append && dataFromBody.length === 0) {
        this.hasNextPage = false;
        return;
      }

      if (append && this.<%= entityInstancePlural %>) {
        // Append new data for "Load More" functionality
        const existingKeys = new Set(this.<%= entityInstancePlural %>.map(item => this.getEntityKey(item)));
        const newItems = dataFromBody.filter(item => !existingKeys.has(this.getEntityKey(item)));
        const combinedData = [...this.<%= entityInstancePlural %>, ...newItems];
        if (newItems.length === 0) {
          this.hasNextPage = false;
          return;
        }
        // Re-sort the entire combined array to maintain sort order
        this.<%= entityInstancePlural %> = this.refineData(combinedData);
      } else {
        // Replace data for initial load or refresh
        this.<%= entityInstancePlural %> = this.refineData(dataFromBody);
      }
      if (this.hasNextPage && this.totalItems !== null && this.<%= entityInstancePlural %>) {
        this.hasNextPage = this.<%= entityInstancePlural %>.length < this.totalItems;
      }
<%_ } else { _%>
      this.<%= entityInstancePlural %> = this.refineData(dataFromBody);
<%_ } _%>
<%_ } else { _%>
      this.<%= entityInstancePlural %> = dataFromBody;
<%_ } _%>
    }

<%_ if (databaseTypeCassandra && paginationNo) { _%>
    protected extractPaginationHeaders(headers: HttpHeaders): void {
      const hasNextPage = headers.get('X-Has-Next-Page');
      this.hasNextPage = hasNextPage === 'true';

      // Extract paging state for next request (cursor-based pagination)
      const pagingStateHeader = headers.get('X-Paging-State');
      this.pagingState = pagingStateHeader || null;

      const totalCountHeader = headers.get('X-Total-Count');
      this.totalItems = totalCountHeader !== null ? Number(totalCountHeader) : null;
    }

    private getEntityKey(item: I<%= entityAngularName %>): string {
<%_ if (primaryKeySaathratri.composite) { _%>
      return this.getCompositeKey(item);
<%_ } else { _%>
      return String(this.<%= entityInstance %>Service.get<%= entityAngularName %>Identifier(item));
<%_ } _%>
    }

<%_ if (primaryKeySaathratri.composite) { _%>
    private getCompositeKey(item: I<%= entityAngularName %>): string {
      const compositeId = item.<%= primaryKeySaathratri.name %>;
      return [
<%_ const compositeIdFieldNames = fields.filter(field => field.isCompositePrimaryKeyField).map(field => field.fieldName); _%>
<%_ compositeIdFieldNames.forEach((fieldName, index) => { _%>
        compositeId.<%= fieldName %><%= index < compositeIdFieldNames.length - 1 ? ',' : '' %>
<%_ }) _%>
      ].join('|');
    }

<%_ } _%>
<%_ } _%>

<%_ if (paginationNo) { _%>
    protected refineData(data: I<%= entityAngularName %>[]): I<%= entityAngularName %>[] {
      const { predicate, order } = this.sortState();
      if (!predicate || !order) {
        return data;
      }

<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) { _%>
      // Composite key fields that are nested in compositeId
      const compositeKeyFields = [<%- compositeKeyFieldNames %>];

      return data.sort((a, b) => {
        let aVal: any;
        let bVal: any;

        // Check if sorting by a composite key field
        if (compositeKeyFields.includes(predicate)) {
          aVal = a.compositeId[predicate as keyof I<%= entityAngularName %>Id];
          bVal = b.compositeId[predicate as keyof I<%= entityAngularName %>Id];
        } else {
          // Regular field
          aVal = (a as any)[predicate];
          bVal = (b as any)[predicate];
        }

        // Handle null/undefined values
        if (aVal == null && bVal == null) return 0;
        if (aVal == null) return 1;
        if (bVal == null) return -1;

        // Compare values
        let result = 0;
        if (typeof aVal === 'string' && typeof bVal === 'string') {
          result = aVal.localeCompare(bVal);
        } else if (aVal < bVal) {
          result = -1;
        } else if (aVal > bVal) {
          result = 1;
        }

        // Apply sort order
        return order === 'asc' ? result : -result;
      });
<%_ } else { _%>
      return data.sort(this.sortService.startSort({ predicate, order }));
<%_ } _%>
    }

<%_ } _%>
    protected fillComponentAttributesFromResponseBody(data: I<%= entityAngularName %>[] | null): I<%= entityAngularName %>[] {
<%_ if (paginationInfiniteScroll) { _%>
      // If there is previous link, data is a infinite scroll pagination content.
      if (this.links().prev) {
        const <%= entityInstancePlural %>New = this.<%= entityInstancePlural %> ?? [];
        if (data) {
          for (const d of data) {
  <%_ if (primaryKey) { _%>
            if (<%= entityInstancePlural %>New.some(op => op.<%= primaryKey.name %> === d.<%= primaryKey.name %>)) {
  <%_ } _%>
              <%= entityInstancePlural %>New.push(d);
  <%_ if (primaryKey) { _%>
            }
  <%_ } _%>
          }
        }
        return <%= entityInstancePlural %>New;
      }
<%_ } _%>
      return data ?? [];
    }

<%_ if (!paginationNo) { _%>
    protected fillComponentAttributesFromResponseHeader(headers: HttpHeaders): void {
  <%_ if (paginationPagination) { _%>
      this.totalItems = Number(headers.get(TOTAL_COUNT_RESPONSE_HEADER));
  <%_ } else if (paginationInfiniteScroll) { _%>
      const linkHeader = headers.get('link');
      if (linkHeader) {
        this.links.set(this.parseLinks.parseAll(linkHeader));
      } else {
        this.links.set({});
      }
    <%_ } _%>
    }

<%_ } _%>
    protected queryBackend(): Observable<EntityArrayResponseType> {
<%_ if (paginationPagination || searchEngineAny) { _%>
      const {
  <%_ if (paginationPagination) { _%>
        page,
  <%_ } _%>
  <%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
        filters,
  <%_ } _%>
  <%_ if (searchEngineAny) { _%>
        currentSearch,
  <%_ } _%>
      } = this;
<%_ } _%>

      this.isLoading = true;
<%_ if (paginationPagination) { _%>
      const pageToLoad: number = page;
<%_ } _%>
      const queryObject<% if ((jpaMetamodelFiltering && paginationPagination) || searchEngine || (databaseTypeCassandra && paginationNo)) { %>: any <% } %> = {
<%_ if (paginationPagination) { _%>
        page: pageToLoad - 1,
<%_ } _%>
<%_ if (!paginationNo) { _%>
        size: this.itemsPerPage,
<%_ } _%>
<%_ if (databaseTypeCassandra && paginationNo) { _%>
        pagingState: this.pagingState,
        size: this.pageSize,
<%_ } _%>
<%_ if(implementsEagerLoadApis || containsBagRelationships) { _%>
        eagerload: true,
<%_ } _%>
<%_ if (searchEngineAny) { _%>
        query: currentSearch,
<%_ } _%>
<%_ if (!paginationInfiniteScroll) { _%>
        sort: this.sortService.buildSortParam(this.sortState()),
<%_ } _%>
      };
<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
      filters.filterOptions.forEach(filterOption => {
        queryObject[filterOption.name] = filterOption.values;
      });
<%_ } _%>
<%_ if (paginationInfiniteScroll) { _%>
      if (this.hasMorePage()) {
        Object.assign(queryObject, this.links().next);
      } else if (this.isFirstFetch()) {
        Object.assign(queryObject, { sort: this.sortService.buildSortParam(this.sortState()) });
      }

<%_ } _%>
<%_ if (searchEngineAny) { _%>
      if (this.currentSearch && this.currentSearch !== '') {
        return this.<%= entityInstance %>Service.search(queryObject)
          .pipe(
            tap(() => this.isLoading = false)
          );
      } else {
<%_ } _%>
<%_ if (databaseTypeCassandra && primaryKeySaathratri.composite) {
    // Get all primary key fields in order
    const allPkFields = primaryKeySaathratri.ids;
    const keyName = primaryKeySaathratri.nameCapitalized;
_%>
        // For Cassandra with composite keys, call the appropriate findBy method
        // based on which search criteria are provided
        if (this.isSearchActive) {
            // Determine which fields have values to select the right endpoint
<%_ // Generate the cascading if-else logic for each combination, starting from the most specific
    for (let i = allPkFields.length - 1; i >= 0; i--) {
        // Build condition to check if fields 0..i all have values
        let conditions = [];
        let methodNameParts = [];
        let methodArgs = [];

        for (let j = 0; j <= i; j++) {
            const field = allPkFields[j];
            methodNameParts.push(`${keyName}${field.fieldNameCapitalized}`);

            // Build condition based on field type
            if (field.fieldTypeTimedSaathratri || field.fieldTypeLocalDateSaathratri) {
                // Date/datetime fields: use computed timestamp value (set by onSearchDateChange)
                conditions.push(`this.searchCriteria.${field.fieldName} !== null && this.searchCriteria.${field.fieldName} !== undefined`);
                methodArgs.push(`this.searchCriteria.${field.fieldName}!`);
            } else if (field.fieldType === 'Boolean') {
                conditions.push(`this.searchCriteria.${field.fieldName} !== null`);
                methodArgs.push(`this.searchCriteria.${field.fieldName}!`);
            } else if (field.fieldTypeNumeric) {
                conditions.push(`this.searchCriteria.${field.fieldName} !== null && this.searchCriteria.${field.fieldName} !== undefined`);
                methodArgs.push(`this.searchCriteria.${field.fieldName}!`);
            } else {
                conditions.push(`this.searchCriteria.${field.fieldName} && this.searchCriteria.${field.fieldName}.trim() !== ''`);
                methodArgs.push(`this.searchCriteria.${field.fieldName}!`);
            }
        }

        const conditionStr = conditions.join(' && ');
        const argsStr = methodArgs.join(', ');
        const isAllKeysProvided = i === allPkFields.length - 1;
        const isFirst = isAllKeysProvided;

        // Check if the last field in this combination supports comparison operators
        const lastField = allPkFields[i];
        const supportsComparison = lastField.isClusteredKeySaathratri &&
            (lastField.fieldType === 'Long' || lastField.fieldTypeTimeUuidSaathratri ||
             lastField.fieldTypeTimedSaathratri || lastField.fieldTypeLocalDateSaathratri);

        const baseMethodName = methodNameParts.join('And');

        // When ALL keys are provided, use findBy (returns single entity)
        // Otherwise use findAllByPageable (returns array)
        if (isAllKeysProvided) {
            const findByMethodName = 'findBy' + baseMethodName;
_%>
            if (<%- conditionStr %>) {
<%_ if (supportsComparison) { _%>
                // Check comparison operator for clustering key field <%= lastField.fieldName %>
                const operator<%= lastField.fieldNameCapitalized %> = this.searchCriteria.<%= lastField.fieldName %>Operator || 'eq';
                if (operator<%= lastField.fieldNameCapitalized %> === 'eq') {
                    // Exact match - use findBy for single record
                    return this.<%= entityInstance %>Service.<%= findByMethodName %>(<%- argsStr %>)
                        .pipe(
                            map((res: EntityResponseType) => {
                                const entity = res.body;
                                return new HttpResponse({
                                    body: entity ? [entity] : [],
                                    headers: res.headers,
                                    status: res.status,
                                });
                            }),
                            tap(() => this.isLoading = false)
                        );
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'lt') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>LessThanPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'lte') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>LessThanEqualPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'gt') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>GreaterThanPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'gte') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>GreaterThanEqualPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                }
                // Fallback to exact match
                return this.<%= entityInstance %>Service.<%= findByMethodName %>(<%- argsStr %>)
                    .pipe(
                        map((res: EntityResponseType) => {
                            const entity = res.body;
                            return new HttpResponse({
                                body: entity ? [entity] : [],
                                headers: res.headers,
                                status: res.status,
                            });
                        }),
                        tap(() => this.isLoading = false)
                    );
<%_ } else { _%>
                // All primary key fields provided - use findBy for exact match (single record)
                return this.<%= entityInstance %>Service.<%= findByMethodName %>(<%- argsStr %>)
                    .pipe(
                        map((res: EntityResponseType) => {
                            // Convert single entity response to array response for display
                            const entity = res.body;
                            return new HttpResponse({
                                body: entity ? [entity] : [],
                                headers: res.headers,
                                status: res.status,
                            });
                        }),
                        tap(() => this.isLoading = false)
                    );
<%_ } _%>
            }
<%_     } else {
            const methodName = 'findAllBy' + baseMethodName + 'Pageable';
_%>
             else if (<%- conditionStr %>) {
<%_ if (supportsComparison) { _%>
                // Check comparison operator for clustering key field <%= lastField.fieldName %>
                const operator<%= lastField.fieldNameCapitalized %> = this.searchCriteria.<%= lastField.fieldName %>Operator || 'eq';
                if (operator<%= lastField.fieldNameCapitalized %> === 'lt') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>LessThanPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'lte') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>LessThanEqualPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'gt') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>GreaterThanPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                } else if (operator<%= lastField.fieldNameCapitalized %> === 'gte') {
                    return this.<%= entityInstance %>Service.findAllBy<%= baseMethodName %>GreaterThanEqualPageable(<%- argsStr %>, queryObject)
                        .pipe(tap(() => this.isLoading = false));
                }
                // Default: 'eq' or no operator - use regular findAllBy
                return this.<%= entityInstance %>Service.<%= methodName %>(<%- argsStr %>, queryObject)
                    .pipe(tap(() => this.isLoading = false));
<%_ } else { _%>
                return this.<%= entityInstance %>Service.<%= methodName %>(<%- argsStr %>, queryObject)
                    .pipe(tap(() => this.isLoading = false));
<%_ } _%>
            }
<%_     }
    } // end for loop _%>
        }
        // Fallback: no search active or no valid criteria, use querySlice (will return empty or all)
        return this.<%= entityInstance %>Service.querySlice(queryObject)
          .pipe(
            tap(() => this.isLoading = false)
          );
<%_ } else if (databaseTypeCassandra && paginationNo) { _%>
        return this.<%= entityInstance %>Service.querySlice(queryObject)
          .pipe(
            tap(() => this.isLoading = false)
          );
<%_ } else { _%>
        return this.<%= entityInstance %>Service.query(queryObject)
          .pipe(
            tap(() => this.isLoading = false)
          );
<%_ } _%>
<%_ if (searchEngineAny) { _%>
      }
<%_ } _%>
    }

    protected handleNavigation(<% if (paginationPagination) { %>page: number, <% } %>sortState: SortState<% if (jpaMetamodelFiltering && paginationPagination) { %>, filterOptions?: IFilterOption[]<% } %><% if (searchEngineAny) { %>, currentSearch?: string<% } %>): void {
<%_ if (paginationInfiniteScroll) { _%>
      this.links.set({});

<%_ } _%>
<%_ if (databaseTypeCassandra && paginationNo) { _%>
      // Reset pagination and clear data when sort changes
      this.pagingState = null;
      this.hasNextPage = false;
      this.totalItems = null;
      this.<%= entityInstancePlural %> = [];

<%_ } _%>
      const queryParamsObj<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>: any<%_ } _%> = {
<%_ if (searchEngineAny) { _%>
        search: currentSearch,
<%_ } _%>
<%_ if (paginationPagination) { _%>
        page,
        size: this.itemsPerPage,
<%_ } _%>
        sort: this.sortService.buildSortParam(sortState),
      };

<%_ if (jpaMetamodelFiltering && paginationPagination) { _%>
      filterOptions?.forEach(filterOption => {
        queryParamsObj[filterOption.nameAsQueryParam()] = filterOption.values;
      });
<%_ } _%>

      this.ngZone.run(() => {
        this.router.navigate(['./'], {
          relativeTo: this.activatedRoute,
          queryParams: queryParamsObj,
        });
      });
    }
}
